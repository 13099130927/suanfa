# 题目描述：链表中倒数第k个节点

题目：

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

题目分析：

自己思考一下

我们遇到这个题目，可能会有什么答题思路呢？

你看我说的对不对，是不是会想到先遍历一遍链表知道 链表节点的个数，然后再计算出倒数第n个节点。

比如链表长度为10，倒数第3个节点，不就是正数第8个节点呀，这种方法当然可以啦，是可以实现的，那么我们再思考一下有没有其他方法呢？哦，对，我们可以将链表元素保存到数组里面，然后直接就可以知道倒数第K个节点了。这个方法确实比刚才那个方法省时间了，但是所耗的空间更多了，那我们还有什么方法吗？

我们可以继续利用我们的双指针呀，但是我们应该怎么做呢？

双指针法：

首先一个指针移动K-1位（这里可以根据你的初始化指针决定），然后另一个指针开始启动，他俩移动速度一样，所以他俩始终相差K-1位，当第一个指针到达链表尾部时，第二个指针的指向则为倒数第K个节点。

![](https://img-blog.csdnimg.cn/img_convert/506c4d70f4c50c66994711c8506462a8.gif)

感觉这个方法既巧妙又简单，大家可以自己动手打一下，这个题目是经典题目。

```java
class Solution {
    public ListNode getKthFromEnd (ListNode head, int k) {
        //特殊情况
        if (head == null) {
            return head;
        }
        //初始化两个指针
        ListNode pro = new ListNode(-1);
        ListNode after = new ListNode(-1);
        //定义指针指向
        pro = head;
        after = head;
        //先移动绿指针到指定位置
        for (int i = 0; i < k-1; i++) {
            pro = pro.next;
        } 
        //两个指针同时移动
        while (pro.next != null) {
            pro = pro.next;
            after = after.next;
        }
        //返回倒数第k个节点
        return after;
    }
}
```

